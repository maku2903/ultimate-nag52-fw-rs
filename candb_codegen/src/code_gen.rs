use std::{collections::HashMap, fs::OpenOptions, path::{Path, PathBuf}};

use crate::parser::{CanDbParser, DataType, Frame, SignalBasic};
use convert_case::{Case, Casing};
use std::fmt::Write;

pub struct EnumInfo {
    pub bit_size: usize,
    pub name: String,
    pub desc: String,
    pub frames: Vec<String>,
    pub tab: Vec<(u32, String, String)>
}

pub struct CodeGenerator {
    // List of ECUs and enums inside for that ECU
    // 1 ECU can have multiple frames with the same
    // enums
    enums: Vec<EnumInfo>,
    db: HashMap<String, Vec<Frame>>,
    out_path: PathBuf
}

impl CodeGenerator {
    pub fn new(db: HashMap<String, Vec<Frame>>, out_path: PathBuf) -> Self {
        let mut enum_tab: Vec<EnumInfo> = vec![];
        for (ecu, frames) in db.iter() {
            for frame in frames {
                for signal in &frame.signals {
                    if let DataType::Enum(enum_) = &signal.dt {
                        if let Some(existing) = enum_tab.iter_mut().find(|x| {
                            x.name == signal.name
                        }) {
                            existing.frames.push(frame.name.clone());
                        } else {
                            enum_tab.push(EnumInfo { 
                                bit_size: signal.len as usize, 
                                name: signal.name.clone(), 
                                desc: signal.desc.clone(),
                                frames: vec![frame.name.clone()],
                                tab: enum_.clone() 
                            });
                        }
                    }
                }
            }
        }
        Self {
            enums: enum_tab,
            out_path,
            db
        }
    }

    pub fn code_gen(&self, layer_name: &String) {
        self.enum_gen();
        for (ecu, frames) in self.db.iter() {
            self.generate_ecu(ecu, frames);
        }
        // Generate MOD file
        let mut s = String::new();
        write!(s,
"
//! CAN Layer for {}
//! 
//! AUTOGENERATED by candb_codegen - DO NOT MODIFY. 
//! Modify the can database instead


", layer_name
);
        writeln!(s, "mod enums;");
        writeln!(s, "pub use enums::*;\n");
        for ecu in self.db.keys() {
            writeln!(s, "mod {};", ecu.to_case(Case::Snake));
            writeln!(s, "pub use {}::*;\n", ecu.to_case(Case::Snake));
        }

        writeln!(s, "pub use super::SignalFrame;");


        let mut mod_file = self.out_path.clone();
        mod_file.push("mod.rs");
        std::fs::write(mod_file, s.as_bytes()).unwrap();

    }

    pub fn enum_gen(&self) {
        let mut s = String::new();
        s.push_str(
r#"
//! Enums used by CAN layer
//! 
//! AUTOGENERATED by candb_codegen - DO NOT MODIFY. 
//! Modify the can database instead

use packed_struct::prelude::*;

"#
);
        for en in self.enums.iter() {
            // Generate enum
            s.push_str(&self.generate_enum(&en));
        }
        let mut enum_file = self.out_path.clone();
        enum_file.push("enums.rs");
        std::fs::write(enum_file, s.as_bytes()).unwrap();
    }

    // Check if an enum is safe (Contains all variants possible)
    pub fn check_enum_is_safe(len_bits: u32, tab: &Vec<(u32, String, String)>) -> bool {
        let max_val = 2u32.pow(len_bits)-1; // Value with all bits set to 1s
        // Easy check, since we should just have as many variants as max_val+1 (to include 0) to indicate its safe
        tab.len() as u32 == max_val + 1
    }

    pub fn generate_ecu(&self, name: &String, frames: &[Frame]) {
        let mut s = String::new();
        s.push_str(&format!(
"
//! CAN ECU {}
//! 
//! AUTOGENERATED by candb_codegen - DO NOT MODIFY. 
//! Modify the can database instead

use packed_struct::prelude::*;
use super::enums::*;

", name
));

        for frame in frames {
            let frame_name = frame.name.to_case(Case::UpperCamel);
            let _ = write!(s, "/// Can Frame DB {}\n", frame.name);
            let _ = write!(s, "#[derive(PackedStruct, Clone, Copy, Debug, PartialEq)]\n");
            let _ = write!(s, "#[packed_struct(bit_numbering=\"msb0\")]\n");
            let _ = write!(s, "pub struct {} {{\n", frame_name);
            
            // Definition
            for signal in &frame.signals {
                let (derrive_args, dt) = match &signal.dt {
                    DataType::Bool => (format!("bits=\"{}\"", signal.offset), "bool".to_string()),
                    DataType::Int { offset:_, multi:_ } => {
                        let ty = match signal.len {
                            x if x <= 8 => "u8",
                            x if x <= 16 => "u16",
                            x if x <= 32 => "u32",
                            _ => "u64"
                        }.to_string();

                        let mut fmt = format!("bits=\"{}..{}\"", signal.offset, signal.offset + signal.len);
                        if signal.len > 8 {
                            // Specify endianness
                            write!(fmt, ", endian=\"msb\"");
                        }

                        (fmt, ty)

                    },
                    DataType::Enum(tab) => {
                        let ty = if Self::check_enum_is_safe(signal.len, tab) {
                            format!("Enum{}",signal.name.clone())
                        } else {
                            format!("EnumCatchAll<Enum{}>", signal.name.clone())
                        };
                        (format!("bits=\"{}..{}\", ty=\"enum\"", signal.offset, signal.offset + signal.len), ty)
                    },
                    DataType::IsoTp => {
                        let bytes = signal.len / 8;
                        (format!("bits=\"{}..{}\"", signal.offset, signal.offset + signal.len), format!("[u8; {}]", bytes))
                    },
                };

                let _ = write!(s, "\t/// {}\n", signal.desc);
                let _ = write!(s, "\t#[packed_field({})]\n", derrive_args);
                let _ = write!(s, "\tpub {}: {},\n", signal.name.to_case(Case::Snake), dt);
            }
            let _ = write!(s, "}}\n\n");

            // Impl (CAN ID)
            let _ = write!(s, "impl super::SignalFrame for {} {{\n", frame_name);
            let _ = write!(s, "\tconst CAN_ID: usize = 0x{:04X};\n", frame.id);
            let _ = write!(s, "}}\n\n");
        }

        let mut ecu_file = self.out_path.clone();
        ecu_file.push(format!("{}.rs", name.to_case(Case::Snake).trim()));
        std::fs::write(ecu_file, s.as_bytes()).unwrap();
    }

    pub fn generate_enum(&self, entry: &EnumInfo) -> String {
        

        let mut s = String::new();
        let derrive_ty = match entry.bit_size {
            x if x <= 8 => "PrimitiveEnum_u8",
            x if x <= 16 => "PrimitiveEnum_u16",
            _ => "PrimitiveEnum_u32",
        };

        if entry.frames.len() == 1 {
            let _ = write!(s, "/// Can Frame {}: {}\n", entry.frames[0], entry.desc);
        } else {
            let _ = write!(s, "/// Can Frames {:?}: {}\n", entry.frames, entry.desc);
        }
        let _ = write!(s, "#[derive({}, Clone, Copy, Debug, PartialEq)]\n", derrive_ty);
        let _ = write!(s, "pub enum Enum{} {{\n", entry.name);
        for val in &entry.tab {
            let _ = write!(s, "\t/// {}\n", val.2); // Description comment
            let _ = write!(s, "\t{} = {},\n", val.1, val.0); // Value
        }
        let _ = write!(s, "}}\n\n");

        s
    }
}